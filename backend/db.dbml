Project "None" {
  database_type: 'PostgreSQL'
  Note: '''None
  Last Updated At 02-12-2026 04:37AM UTC'''
}

enum admin.positive_small_integer_logentry_action_flag {
  "1" [note: '''Addition''']
  "2" [note: '''Change''']
  "3" [note: '''Deletion''']
}

Table admin.LogEntry {
  Note: '''
LogEntry(id, action_time, user, content_type, object_id, object_repr, action_flag, change_message)

*DB table: django_admin_log*'''

  id auto [pk, unique, not null]
  action_time date_time [default:`django.utils.timezone.now()`, not null]
  user_id foreign_key [not null]
  content_type_id foreign_key [null]
  object_id text [null]
  object_repr char [not null]
  action_flag admin.positive_small_integer_logentry_action_flag [not null]
  change_message text [not null]

  indexes {
    (content_type_id) [name: 'django_admin_log_content_type_id_c4bce8eb', type: btree]
    (id) [pk, unique, name: 'django_admin_log_pkey', type: btree]
    (user_id) [name: 'django_admin_log_user_id_c564eba6', type: btree]
  }
}
ref: admin.LogEntry.user_id > v1_users.SystemUser.id
ref: admin.LogEntry.content_type_id > contenttypes.ContentType.id


Table auth.Group {
  Note: '''
Groups are a generic way of categorizing users to apply permissions, or
some other label, to those users. A user can belong to any number of
groups.

A user in a group automatically has all the permissions granted to that
group. For example, if the group 'Site editors' has the permission
can_edit_home_page, any user in that group will have that permission.

Beyond permissions, groups are a convenient way to categorize users to
apply some label, or extended functionality, to them. For example, you
could create a group 'Special users', and you could write code that would
do special things to those users -- such as giving them access to a
members-only portion of your site, or sending them members-only email
messages.


*DB table: auth_group*'''

  id auto [pk, unique, not null]
  name char [unique, not null]

  indexes {
    (name) [unique, name: 'auth_group_name_key', type: btree]
    (id) [pk, unique, name: 'auth_group_pkey', type: btree]
  }
}


Table auth.Permission {
  Note: '''
The permissions system provides a way to assign permissions to specific
users and groups of users.

The permission system is used by the Django admin site, but may also be
useful in your own code. The Django admin site uses permissions as follows:

- The "add" permission limits the user's ability to view the "add" form
and add an object.
- The "change" permission limits a user's ability to view the change
list, view the "change" form and change an object.
- The "delete" permission limits the ability to delete an object.
- The "view" permission limits the ability to view an object.

Permissions are set globally per type of object, not per specific object
instance. It is possible to say "Mary may change news stories," but it's
not currently possible to say "Mary may change news stories, but only the
ones she created herself" or "Mary may only change news stories that have a
certain status or publication date."

The permissions listed above are automatically created for each model.


*DB table: auth_permission*'''

  id auto [pk, unique, not null]
  name char [not null]
  content_type_id foreign_key [not null]
  codename char [not null]

  indexes {
    (content_type_id) [name: 'auth_permission_content_type_id_2f476e4b', type: btree]
    (content_type_id,codename) [unique, name: 'auth_permission_content_type_id_codename_01ab375a_uniq', type: btree]
    (id) [pk, unique, name: 'auth_permission_pkey', type: btree]
  }
}
ref: auth.Permission.content_type_id > contenttypes.ContentType.id


Table auth.group_permissions {
  Note: '''
This is a Many-To-Many linking table autogenerated by Django.

*DB table: auth_group_permissions*'''

  id auto [pk, not null]
  permission_id auto
  group_id auto

  indexes {
    (group_id) [name: 'auth_group_permissions_group_id_b120cbf9', type: btree]
    (group_id,permission_id) [unique, name: 'auth_group_permissions_group_id_permission_id_0cd325b0_uniq', type: btree]
    (permission_id) [name: 'auth_group_permissions_permission_id_84c5c92e', type: btree]
    (id) [pk, unique, name: 'auth_group_permissions_pkey', type: btree]
  }
}
ref: auth.Group.id > auth.group_permissions.group_id
ref: auth.Permission.id > auth.group_permissions.permission_id


Table contenttypes.ContentType {
  Note: '''
ContentType(id, app_label, model)

*DB table: django_content_type*'''

  id auto [pk, unique, not null]
  app_label char [not null]
  model char [not null]

  indexes {
    (app_label,model) [unique, name: 'django_content_type_app_label_model_76bd3d3b_uniq', type: btree]
    (id) [pk, unique, name: 'django_content_type_pkey', type: btree]
  }
}


Table sessions.Session {
  Note: '''
Django provides full support for anonymous sessions. The session
framework lets you store and retrieve arbitrary data on a
per-site-visitor basis. It stores data on the server side and
abstracts the sending and receiving of cookies. Cookies contain a
session ID -- not the data itself.

The Django sessions framework is entirely cookie-based. It does
not fall back to putting session IDs in URLs. This is an intentional
design decision. Not only does that behavior make URLs ugly, it makes
your site vulnerable to session-ID theft via the "Referer" header.

For complete documentation on using Sessions in your code, consult
the sessions documentation that is shipped with Django (also available
on the Django web site).


*DB table: django_session*'''

  session_key char [pk, unique, not null]
  session_data text [not null]
  expire_date date_time [not null]

  indexes {
    (expire_date) [name: 'django_session_expire_date_a5c62663', type: btree]
    (session_key) [pk, unique, name: 'django_session_pkey', type: btree]
  }
}


Table system.user_groups {
  Note: '''
This is a Many-To-Many linking table autogenerated by Django.

*DB table: system_user_groups*'''

  id auto [pk, not null]
  group_id auto
  systemuser_id auto

  indexes {
    (group_id) [name: 'system_user_groups_group_id_925e6bcb', type: btree]
    (id) [pk, unique, name: 'system_user_groups_pkey', type: btree]
    (systemuser_id) [name: 'system_user_groups_systemuser_id_fd40b5de', type: btree]
    (systemuser_id,group_id) [unique, name: 'system_user_groups_systemuser_id_group_id_80e3523a_uniq', type: btree]
  }
}
ref: v1_users.SystemUser.id > system.user_groups.systemuser_id
ref: auth.Group.id > system.user_groups.group_id


Table system.user_user_permissions {
  Note: '''
This is a Many-To-Many linking table autogenerated by Django.

*DB table: system_user_user_permissions*'''

  id auto [pk, not null]
  permission_id auto
  systemuser_id auto

  indexes {
    (systemuser_id,permission_id) [unique, name: 'system_user_user_permiss_systemuser_id_permission_94a6ae3b_uniq', type: btree]
    (permission_id) [name: 'system_user_user_permissions_permission_id_9339fa91', type: btree]
    (id) [pk, unique, name: 'system_user_user_permissions_pkey', type: btree]
    (systemuser_id) [name: 'system_user_user_permissions_systemuser_id_ffc78fa7', type: btree]
  }
}
ref: v1_users.SystemUser.id > system.user_user_permissions.systemuser_id
ref: auth.Permission.id > system.user_user_permissions.permission_id


Table v1_odk.FormMetadata {
  Note: '''
FormMetadata(asset_uid, name, last_sync_timestamp)

*DB table: form_metadata*'''

  asset_uid char [pk, unique, not null]
  name char [note: '''Form display name''', default:`""`, not null]
  last_sync_timestamp big_integer [note: '''Epoch ms of last successful sync''', default:`0`, not null]

  indexes {
    (asset_uid) [pk, unique, name: 'form_metadata_pkey', type: btree]
  }
}


Table v1_odk.Plot {
  Note: '''
Plot(uuid, plot_name, instance_name, polygon_wkt, min_lat, max_lat, min_lon, max_lon, is_draft, form_id, region, sub_region, created_at, submission)

*DB table: plots*'''

  uuid char [pk, unique, default:`uuid.uuid4()`, not null]
  plot_name char [note: '''Farmer full name''', not null]
  instance_name char [not null]
  polygon_wkt text [note: '''Polygon in WKT format''', not null]
  min_lat float [not null]
  max_lat float [not null]
  min_lon float [not null]
  max_lon float [not null]
  is_draft boolean [default:`True`, not null]
  form_id char [not null]
  region char [not null]
  sub_region char [not null]
  created_at big_integer [note: '''Epoch ms''', not null]
  submission_id one_to_one [unique, null]

  indexes {
    (instance_name) [name: 'plots_instance_name_f647d82d', type: btree]
    (max_lat) [name: 'plots_max_lat_d09f5e4c', type: btree]
    (max_lon) [name: 'plots_max_lon_307afe7e', type: btree]
    (min_lat) [name: 'plots_min_lat_b87f6f09', type: btree]
    (min_lon) [name: 'plots_min_lon_012245da', type: btree]
    (uuid) [pk, unique, name: 'plots_pkey', type: btree]
    (submission_id) [unique, name: 'plots_submission_id_key', type: btree]
  }
}
ref: v1_odk.Plot.submission_id - v1_odk.Submission.uuid


Table v1_odk.Submission {
  Note: '''
Submission(uuid, form, kobo_id, submission_time, submitted_by, instance_name, raw_data, system_data)

*DB table: submissions*'''

  uuid char [pk, unique, not null]
  form_id foreign_key [not null]
  kobo_id char [not null]
  submission_time big_integer [note: '''Epoch ms''', not null]
  submitted_by char [null]
  instance_name char [null]
  raw_data json [note: '''Full dynamic form JSON''', not null]
  system_data json [note: '''_geolocation, _tags, etc.''', null]

  indexes {
    (form_id) [name: 'submissions_form_id_1c5a5ef9', type: btree]
    (instance_name) [name: 'submissions_instance_name_437afa7b', type: btree]
    (uuid) [pk, unique, name: 'submissions_pkey', type: btree]
    (submission_time) [name: 'submissions_submission_time_a6375f5b', type: btree]
  }
}
ref: v1_odk.Submission.form_id > v1_odk.FormMetadata.asset_uid


Table v1_users.SystemUser {
  Note: '''
SystemUser(id, password, last_login, is_superuser, deleted_at, email, name, email_verified, email_verification_code, email_verification_expiry, reset_password_code, reset_password_code_expiry, kobo_url, kobo_username, kobo_password)

*DB table: system_user*'''

  id big_auto [pk, unique, not null]
  password char [not null]
  last_login date_time [null]
  is_superuser boolean [note: '''Designates that this user has all permissions without explicitly assigning them.''', default:`False`, not null]
  deleted_at date_time [null]
  email email [unique, not null]
  name char [not null]
  email_verified boolean [default:`False`, not null]
  email_verification_code uuid [default:`None`, null]
  email_verification_expiry date_time [null]
  reset_password_code uuid [default:`None`, null]
  reset_password_code_expiry date_time [null]
  kobo_url url [note: '''KoboToolbox server URL''', null]
  kobo_username char [note: '''KoboToolbox username''', null]
  kobo_password text [note: '''Encrypted KoboToolbox password''', null]

  indexes {
    (email) [unique, name: 'system_user_email_key', type: btree]
    (id) [pk, unique, name: 'system_user_pkey', type: btree]
  }
}


